# 数据结构

课程链接：[03-BTC-数据结构_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Vt411X7JF?p=3&vd_source=6e70ae8e9395c062a70e813c359b470e)

**数据结构一:block chain**

### 链

1.hash pointers 

![image-20240627152240196](C:\Users\admin\Desktop\learing\BTC\数据结构.assets\image-20240627152240196.png)

**Block chain is a linked list using hash pointers.**

**区块链用 hash 指针 取代了普通指针。**



**example:**

创世区块：Genesis block

最近一个区块：most recent block

![image-20240627152541252](C:\Users\admin\Desktop\learing\BTC\数据结构.assets\image-20240627152541252.png)

每一个  H（） 是将前一个区块中所有的信息hash， 这其中包括前一个区块中的 H（）。

这种数据结构可以实现 :

**tamper - evident log** ：

如果有恶意用户要修改其中某一个节点，那后面每个区块中的 H（）都会随之改变，牵一发而动全身。

这样也有一个好处，一些节点只需要保存  最近的区块 就可以验证区块链的合法性和信息。





**数据结构二:Merkle tree**

## 2. Merkle Tree

与二叉树/binary tree ，Merkle Tree用hash pointers 代替了 普通 pointers

![image-20240627154553724](C:\Users\admin\Desktop\learing\BTC\数据结构.assets\image-20240627154553724.png)

![image-20240627155243357](C:\Users\admin\Desktop\learing\BTC\数据结构.assets\image-20240627155243357.png)

和 之前数据结构一个道理只要记住最上面的 H（） root hash 就可以检测树中任何部位的修改。



每个区块可以分为块头和块身：

block hearder  包含： 整个区块（block）中 的交易组成的一个  Merkle tree  的 root hash。

block body 包含 ： 交易列表，所有交易的完整信息。



## Merkle tree 的作用：

1. merkle proof 

BTC中节点分为两类 ：

**全节点**  ： 保存整个区块的内容 ， 包含  block header 和  block body  ，是有详细的交易信息的

**轻节点**  ： 例如 BTC 钱包的应用 ，只保存 Blcok Header 。

全节点中包含交易信息，所以好证明交易的合法性，但轻节点只有头部信息 （block header）， 这里就需要 

Merkle proof :

![image-20240627163201905](C:\Users\admin\Desktop\learing\BTC\数据结构.assets\image-20240627163201905.png) 

关于轻节点的**两个要素**：

**Proof of membership**

**Proof of inclusion**

证明交易的合法性

难度是



那如何证明交易的不合法性  proof of non-membership

代价是需要根据对   tx  的  hash 值进行排序，就会有 Sorted Merkle Tree

 但  BTC  不需要不合法证明没有硬性要求，所以 不需要排序的这道工作